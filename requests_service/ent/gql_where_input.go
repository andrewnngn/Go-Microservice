// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"golang-boilerplate/ent/predicate"
	"golang-boilerplate/ent/request"
	"time"
)

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "contract_id" field predicates.
	ContractID      *int  `json:"contractID,omitempty"`
	ContractIDNEQ   *int  `json:"contractIDNEQ,omitempty"`
	ContractIDIn    []int `json:"contractIDIn,omitempty"`
	ContractIDNotIn []int `json:"contractIDNotIn,omitempty"`
	ContractIDGT    *int  `json:"contractIDGT,omitempty"`
	ContractIDGTE   *int  `json:"contractIDGTE,omitempty"`
	ContractIDLT    *int  `json:"contractIDLT,omitempty"`
	ContractIDLTE   *int  `json:"contractIDLTE,omitempty"`

	// "vendor_id" field predicates.
	VendorID      *int  `json:"vendorID,omitempty"`
	VendorIDNEQ   *int  `json:"vendorIDNEQ,omitempty"`
	VendorIDIn    []int `json:"vendorIDIn,omitempty"`
	VendorIDNotIn []int `json:"vendorIDNotIn,omitempty"`
	VendorIDGT    *int  `json:"vendorIDGT,omitempty"`
	VendorIDGTE   *int  `json:"vendorIDGTE,omitempty"`
	VendorIDLT    *int  `json:"vendorIDLT,omitempty"`
	VendorIDLTE   *int  `json:"vendorIDLTE,omitempty"`

	// "contractor_id" field predicates.
	ContractorID      *int  `json:"contractorID,omitempty"`
	ContractorIDNEQ   *int  `json:"contractorIDNEQ,omitempty"`
	ContractorIDIn    []int `json:"contractorIDIn,omitempty"`
	ContractorIDNotIn []int `json:"contractorIDNotIn,omitempty"`
	ContractorIDGT    *int  `json:"contractorIDGT,omitempty"`
	ContractorIDGTE   *int  `json:"contractorIDGTE,omitempty"`
	ContractorIDLT    *int  `json:"contractorIDLT,omitempty"`
	ContractorIDLTE   *int  `json:"contractorIDLTE,omitempty"`

	// "amount" field predicates.
	Amount      *int  `json:"amount,omitempty"`
	AmountNEQ   *int  `json:"amountNEQ,omitempty"`
	AmountIn    []int `json:"amountIn,omitempty"`
	AmountNotIn []int `json:"amountNotIn,omitempty"`
	AmountGT    *int  `json:"amountGT,omitempty"`
	AmountGTE   *int  `json:"amountGTE,omitempty"`
	AmountLT    *int  `json:"amountLT,omitempty"`
	AmountLTE   *int  `json:"amountLTE,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "collection_date" field predicates.
	CollectionDate       *time.Time  `json:"collectionDate,omitempty"`
	CollectionDateNEQ    *time.Time  `json:"collectionDateNEQ,omitempty"`
	CollectionDateIn     []time.Time `json:"collectionDateIn,omitempty"`
	CollectionDateNotIn  []time.Time `json:"collectionDateNotIn,omitempty"`
	CollectionDateGT     *time.Time  `json:"collectionDateGT,omitempty"`
	CollectionDateGTE    *time.Time  `json:"collectionDateGTE,omitempty"`
	CollectionDateLT     *time.Time  `json:"collectionDateLT,omitempty"`
	CollectionDateLTE    *time.Time  `json:"collectionDateLTE,omitempty"`
	CollectionDateIsNil  bool        `json:"collectionDateIsNil,omitempty"`
	CollectionDateNotNil bool        `json:"collectionDateNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.ContractID != nil {
		predicates = append(predicates, request.ContractIDEQ(*i.ContractID))
	}
	if i.ContractIDNEQ != nil {
		predicates = append(predicates, request.ContractIDNEQ(*i.ContractIDNEQ))
	}
	if len(i.ContractIDIn) > 0 {
		predicates = append(predicates, request.ContractIDIn(i.ContractIDIn...))
	}
	if len(i.ContractIDNotIn) > 0 {
		predicates = append(predicates, request.ContractIDNotIn(i.ContractIDNotIn...))
	}
	if i.ContractIDGT != nil {
		predicates = append(predicates, request.ContractIDGT(*i.ContractIDGT))
	}
	if i.ContractIDGTE != nil {
		predicates = append(predicates, request.ContractIDGTE(*i.ContractIDGTE))
	}
	if i.ContractIDLT != nil {
		predicates = append(predicates, request.ContractIDLT(*i.ContractIDLT))
	}
	if i.ContractIDLTE != nil {
		predicates = append(predicates, request.ContractIDLTE(*i.ContractIDLTE))
	}
	if i.VendorID != nil {
		predicates = append(predicates, request.VendorIDEQ(*i.VendorID))
	}
	if i.VendorIDNEQ != nil {
		predicates = append(predicates, request.VendorIDNEQ(*i.VendorIDNEQ))
	}
	if len(i.VendorIDIn) > 0 {
		predicates = append(predicates, request.VendorIDIn(i.VendorIDIn...))
	}
	if len(i.VendorIDNotIn) > 0 {
		predicates = append(predicates, request.VendorIDNotIn(i.VendorIDNotIn...))
	}
	if i.VendorIDGT != nil {
		predicates = append(predicates, request.VendorIDGT(*i.VendorIDGT))
	}
	if i.VendorIDGTE != nil {
		predicates = append(predicates, request.VendorIDGTE(*i.VendorIDGTE))
	}
	if i.VendorIDLT != nil {
		predicates = append(predicates, request.VendorIDLT(*i.VendorIDLT))
	}
	if i.VendorIDLTE != nil {
		predicates = append(predicates, request.VendorIDLTE(*i.VendorIDLTE))
	}
	if i.ContractorID != nil {
		predicates = append(predicates, request.ContractorIDEQ(*i.ContractorID))
	}
	if i.ContractorIDNEQ != nil {
		predicates = append(predicates, request.ContractorIDNEQ(*i.ContractorIDNEQ))
	}
	if len(i.ContractorIDIn) > 0 {
		predicates = append(predicates, request.ContractorIDIn(i.ContractorIDIn...))
	}
	if len(i.ContractorIDNotIn) > 0 {
		predicates = append(predicates, request.ContractorIDNotIn(i.ContractorIDNotIn...))
	}
	if i.ContractorIDGT != nil {
		predicates = append(predicates, request.ContractorIDGT(*i.ContractorIDGT))
	}
	if i.ContractorIDGTE != nil {
		predicates = append(predicates, request.ContractorIDGTE(*i.ContractorIDGTE))
	}
	if i.ContractorIDLT != nil {
		predicates = append(predicates, request.ContractorIDLT(*i.ContractorIDLT))
	}
	if i.ContractorIDLTE != nil {
		predicates = append(predicates, request.ContractorIDLTE(*i.ContractorIDLTE))
	}
	if i.Amount != nil {
		predicates = append(predicates, request.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, request.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, request.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, request.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, request.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, request.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, request.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, request.AmountLTE(*i.AmountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}
	if i.CollectionDate != nil {
		predicates = append(predicates, request.CollectionDateEQ(*i.CollectionDate))
	}
	if i.CollectionDateNEQ != nil {
		predicates = append(predicates, request.CollectionDateNEQ(*i.CollectionDateNEQ))
	}
	if len(i.CollectionDateIn) > 0 {
		predicates = append(predicates, request.CollectionDateIn(i.CollectionDateIn...))
	}
	if len(i.CollectionDateNotIn) > 0 {
		predicates = append(predicates, request.CollectionDateNotIn(i.CollectionDateNotIn...))
	}
	if i.CollectionDateGT != nil {
		predicates = append(predicates, request.CollectionDateGT(*i.CollectionDateGT))
	}
	if i.CollectionDateGTE != nil {
		predicates = append(predicates, request.CollectionDateGTE(*i.CollectionDateGTE))
	}
	if i.CollectionDateLT != nil {
		predicates = append(predicates, request.CollectionDateLT(*i.CollectionDateLT))
	}
	if i.CollectionDateLTE != nil {
		predicates = append(predicates, request.CollectionDateLTE(*i.CollectionDateLTE))
	}
	if i.CollectionDateIsNil {
		predicates = append(predicates, request.CollectionDateIsNil())
	}
	if i.CollectionDateNotNil {
		predicates = append(predicates, request.CollectionDateNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, request.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, request.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, request.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, request.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, request.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, request.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, request.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, request.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, request.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, request.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, request.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, request.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, request.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, request.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, request.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, request.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}
